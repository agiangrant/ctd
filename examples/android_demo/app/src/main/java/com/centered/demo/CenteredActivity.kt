package com.centered.demo

import android.app.NativeActivity
import android.content.Context
import android.os.Build
import android.os.Bundle
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import android.text.Editable
import android.text.TextWatcher
import android.view.KeyEvent
import android.view.View
import android.view.WindowInsets
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputMethodManager
import android.widget.EditText
import android.widget.FrameLayout
import androidx.annotation.Keep
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsAnimationCompat
import androidx.core.view.WindowInsetsCompat

/**
 * CenteredActivity extends NativeActivity to provide a native Android app
 * that hosts the Centered engine (Rust + Go).
 *
 * NativeActivity provides proper surface management for native game engines
 * like wgpu. The android-activity Rust crate (with native-activity feature)
 * handles the native lifecycle.
 *
 * This activity provides JNI helper methods that Rust can call for:
 * - Software keyboard show/hide
 * - Safe area insets (display cutouts, navigation bar)
 * - Haptic feedback
 * - Scale factor (DPI)
 */
class CenteredActivity : NativeActivity() {

    companion object {
        init {
            // Load native libraries
            // Order matters: centered_engine must be loaded first
            System.loadLibrary("centered_engine")
            System.loadLibrary("gojni")  // Generated by gomobile (always named libgojni.so)
        }

        private const val TAG = "CenteredActivity"
    }

    private lateinit var imm: InputMethodManager
    private var vibrator: Vibrator? = null
    private lateinit var hiddenEditText: EditText
    private var isProcessingTextChange = false
    private var lastKeyboardHeight: Float = 0f

    // Native method declarations - implemented in Rust
    private external fun nativeOnTextInput(text: String)
    private external fun nativeOnKeyEvent(keyCode: Int, action: Int): Boolean
    private external fun nativeOnKeyboardHeightChanged(height: Float, animationDurationMs: Int)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Initialize services
        imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager

        vibrator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
            vibratorManager.defaultVibrator
        } else {
            @Suppress("DEPRECATION")
            getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        }

        // Enable edge-to-edge for proper insets handling
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.setDecorFitsSystemWindows(false)
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (
                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            )
        }

        // Create hidden EditText for keyboard input capture
        setupHiddenEditText()

        // Set up keyboard height change listener for scroll adjustments
        setupKeyboardInsetsListener()
    }

    private fun setupHiddenEditText() {
        try {
            // Create a small but functional EditText to capture keyboard input
            hiddenEditText = EditText(this).apply {
                // Make it small and positioned at top-left, nearly transparent
                alpha = 0.02f
                setBackgroundColor(0x01000000)  // Nearly transparent background
                setTextColor(0x01000000)  // Nearly transparent text

                // Give it enough size to be focusable (some devices need minimum size)
                layoutParams = FrameLayout.LayoutParams(50, 50).apply {
                    // Position at top-left corner
                    gravity = android.view.Gravity.TOP or android.view.Gravity.START
                }

                // Configure for general text input
                inputType = EditorInfo.TYPE_CLASS_TEXT or EditorInfo.TYPE_TEXT_FLAG_NO_SUGGESTIONS
                imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI or EditorInfo.IME_ACTION_NONE

                // Don't show predictive text bar
                privateImeOptions = "nm"

                // Ensure it can receive focus
                isFocusable = true
                isFocusableInTouchMode = true
                visibility = View.VISIBLE
                isEnabled = true
            }

            // Add text change listener to capture typed text
            hiddenEditText.addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

                override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                    if (isProcessingTextChange) return

                    val newText = s?.toString() ?: ""

                    // Detect what was added
                    if (count > 0 && before == 0) {
                        // Text was added
                        val addedText = newText.substring(start, start + count)
                        if (addedText.isNotEmpty()) {
                            try {
                                nativeOnTextInput(addedText)
                            } catch (e: Exception) {
                                android.util.Log.e(TAG, "nativeOnTextInput failed: ${e.message}")
                            }
                        }
                    }
                }

                override fun afterTextChanged(s: Editable?) {
                    // Clear the edit text after processing to keep it simple
                    if (!isProcessingTextChange && !s.isNullOrEmpty()) {
                        isProcessingTextChange = true
                        s.clear()
                        isProcessingTextChange = false
                    }
                }
            })

            // Handle special keys (backspace, enter, etc.)
            hiddenEditText.setOnKeyListener { _, keyCode, event ->
                if (event.action == KeyEvent.ACTION_DOWN) {
                    when (keyCode) {
                        KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_ENTER -> {
                            try {
                                nativeOnKeyEvent(keyCode, event.action)
                            } catch (e: Exception) {
                                android.util.Log.e(TAG, "nativeOnKeyEvent failed: ${e.message}")
                            }
                            true
                        }
                        else -> false
                    }
                } else {
                    false
                }
            }

            // Add the EditText using addContentView which works better with GameActivity
            val layoutParams = FrameLayout.LayoutParams(50, 50).apply {
                gravity = android.view.Gravity.TOP or android.view.Gravity.START
            }
            addContentView(hiddenEditText, layoutParams)

            android.util.Log.i(TAG, "Hidden EditText setup complete, size: 50x50")
        } catch (e: Exception) {
            android.util.Log.e(TAG, "Failed to setup hidden EditText: ${e.message}")
        }
    }

    /**
     * Set up a listener for keyboard (IME) insets changes.
     * This allows us to notify Rust when the keyboard appears/disappears
     * so it can scroll content to keep focused inputs visible.
     */
    private fun setupKeyboardInsetsListener() {
        try {
            val decorView = window.decorView

            // Use WindowInsetsAnimationCompat.Callback for smooth keyboard animations
            ViewCompat.setWindowInsetsAnimationCallback(
                decorView,
                object : WindowInsetsAnimationCompat.Callback(DISPATCH_MODE_STOP) {
                    override fun onProgress(
                        insets: WindowInsetsCompat,
                        runningAnimations: MutableList<WindowInsetsAnimationCompat>
                    ): WindowInsetsCompat {
                        // Called during keyboard animation - we don't need frame-by-frame updates
                        return insets
                    }

                    override fun onEnd(animation: WindowInsetsAnimationCompat) {
                        super.onEnd(animation)
                        // Animation finished - notify Rust of final keyboard height
                        checkAndNotifyKeyboardHeight(animation.durationMillis.toInt())
                    }
                }
            )

            // Also listen for insets changes to catch non-animated changes
            ViewCompat.setOnApplyWindowInsetsListener(decorView) { view, insets ->
                checkAndNotifyKeyboardHeight(250) // Default animation duration
                ViewCompat.onApplyWindowInsets(view, insets)
            }

            android.util.Log.i(TAG, "Keyboard insets listener setup complete")
        } catch (e: Exception) {
            android.util.Log.e(TAG, "Failed to setup keyboard insets listener: ${e.message}")
        }
    }

    /**
     * Check current keyboard height and notify Rust if it changed.
     */
    private fun checkAndNotifyKeyboardHeight(animationDurationMs: Int) {
        val density = resources.displayMetrics.density
        val currentHeight = ViewCompat.getRootWindowInsets(window.decorView)?.let { windowInsets ->
            val imeInsets = windowInsets.getInsets(WindowInsetsCompat.Type.ime())
            imeInsets.bottom / density
        } ?: 0f

        // Only notify if height actually changed
        if (currentHeight != lastKeyboardHeight) {
            android.util.Log.i(TAG, "Keyboard height changed: $lastKeyboardHeight -> $currentHeight (duration: ${animationDurationMs}ms)")
            lastKeyboardHeight = currentHeight

            try {
                nativeOnKeyboardHeightChanged(currentHeight, animationDurationMs)
            } catch (e: Exception) {
                android.util.Log.e(TAG, "nativeOnKeyboardHeightChanged failed: ${e.message}")
            }
        }
    }

    // =========================================================================
    // JNI Methods - Called from Rust via JNI
    // These methods are marked @Keep to prevent ProGuard from removing them
    // =========================================================================

    /**
     * Show the software keyboard
     */
    @Keep
    fun showSoftKeyboard() {
        android.util.Log.i(TAG, "showSoftKeyboard called")
        runOnUiThread {
            try {
                // Check if hiddenEditText is initialized
                if (!::hiddenEditText.isInitialized) {
                    android.util.Log.e(TAG, "showSoftKeyboard: hiddenEditText not initialized yet")
                    return@runOnUiThread
                }

                // Request focus on the hidden EditText
                hiddenEditText.requestFocus()
                android.util.Log.i(TAG, "showSoftKeyboard: requestFocus called")

                // Show keyboard with the EditText as target
                val shown = imm.showSoftInput(hiddenEditText, InputMethodManager.SHOW_IMPLICIT)
                android.util.Log.i(TAG, "showSoftKeyboard: showSoftInput returned $shown")

                // If showSoftInput didn't work, try alternative methods
                if (!shown) {
                    // Try forcing the keyboard to show
                    imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY)
                    android.util.Log.i(TAG, "showSoftKeyboard: toggleSoftInput fallback called")
                }
            } catch (e: Exception) {
                android.util.Log.e(TAG, "showSoftKeyboard failed: ${e.message}")
                e.printStackTrace()
            }
        }
    }

    /**
     * Hide the software keyboard
     */
    @Keep
    fun hideSoftKeyboard() {
        android.util.Log.i(TAG, "hideSoftKeyboard called")
        runOnUiThread {
            try {
                // Check if hiddenEditText is initialized
                if (!::hiddenEditText.isInitialized) {
                    android.util.Log.e(TAG, "hideSoftKeyboard: hiddenEditText not initialized yet")
                    return@runOnUiThread
                }

                // Clear focus from EditText
                hiddenEditText.clearFocus()

                // Hide keyboard using the window token
                imm.hideSoftInputFromWindow(hiddenEditText.windowToken, 0)
                android.util.Log.i(TAG, "hideSoftKeyboard: hideSoftInputFromWindow called")
            } catch (e: Exception) {
                android.util.Log.e(TAG, "hideSoftKeyboard failed: ${e.message}")
                e.printStackTrace()
            }
        }
    }

    /**
     * Get safe area insets as a float array [top, left, bottom, right] in dp
     * Accounts for display cutouts (notch), status bar, and navigation bar
     */
    @Keep
    fun getSafeAreaInsets(): FloatArray {
        val insets = floatArrayOf(0f, 0f, 0f, 0f)  // top, left, bottom, right
        val density = resources.displayMetrics.density

        // Use AndroidX WindowInsetsCompat for backward compatibility
        ViewCompat.getRootWindowInsets(window.decorView)?.let { windowInsets ->
            // Get system bars (status bar, navigation bar)
            val systemBars = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            insets[0] = systemBars.top / density
            insets[1] = systemBars.left / density
            insets[2] = systemBars.bottom / density
            insets[3] = systemBars.right / density

            // Get display cutout on API 28+
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                val cutout = windowInsets.displayCutout
                cutout?.let {
                    insets[0] = maxOf(insets[0], it.safeInsetTop / density)
                    insets[1] = maxOf(insets[1], it.safeInsetLeft / density)
                    insets[2] = maxOf(insets[2], it.safeInsetBottom / density)
                    insets[3] = maxOf(insets[3], it.safeInsetRight / density)
                }
            }
        }

        return insets
    }

    /**
     * Trigger haptic feedback
     * @param style 0=Light, 1=Medium, 2=Heavy, 3=Selection, 4=Success, 5=Warning, 6=Error
     */
    @Keep
    fun hapticFeedback(style: Int) {
        val v = vibrator ?: return

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Android 10+: Use predefined effects
            val effect = when (style) {
                0 -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_TICK)
                1 -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_CLICK)
                2 -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_HEAVY_CLICK)
                3 -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_TICK)
                4 -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_DOUBLE_CLICK)
                5, 6 -> VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE)
                else -> VibrationEffect.createPredefined(VibrationEffect.EFFECT_CLICK)
            }
            v.vibrate(effect)
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            // Android 8-9: Use one-shot vibration
            val duration = when (style) {
                0 -> 10L
                1 -> 20L
                2 -> 50L
                3 -> 5L
                else -> 20L
            }
            v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))
        } else {
            // Older Android: Simple vibration
            @Suppress("DEPRECATION")
            v.vibrate(20)
        }
    }

    /**
     * Get the display scale factor (DPI / 160)
     */
    @Keep
    fun getScaleFactor(): Float {
        return resources.displayMetrics.density
    }

    /**
     * Check if keyboard is currently visible
     */
    @Keep
    fun isKeyboardVisible(): Boolean {
        ViewCompat.getRootWindowInsets(window.decorView)?.let { windowInsets ->
            return windowInsets.isVisible(WindowInsetsCompat.Type.ime())
        }
        return false
    }

    /**
     * Get keyboard height in dp (0 if hidden)
     */
    @Keep
    fun getKeyboardHeight(): Float {
        val density = resources.displayMetrics.density
        ViewCompat.getRootWindowInsets(window.decorView)?.let { windowInsets ->
            val imeInsets = windowInsets.getInsets(WindowInsetsCompat.Type.ime())
            return imeInsets.bottom / density
        }
        return 0f
    }
}
