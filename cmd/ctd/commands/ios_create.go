package commands

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// CreateIOS implements the 'ctd create-ios' command
func CreateIOS(args []string) error {
	fs := flag.NewFlagSet("create-ios", flag.ExitOnError)
	name := fs.String("name", "", "App name (defaults to project name from centered.toml)")
	outputDir := fs.String("output", "ios", "Output directory for iOS project")
	force := fs.Bool("force", false, "Overwrite existing files")
	fs.Parse(args)

	// Load project config
	config, err := LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Use provided name or fall back to config
	appName := *name
	if appName == "" {
		appName = config.App.Name
	}

	// Sanitize app name for use in identifiers
	safeName := sanitizeName(appName)

	// Check if output directory exists
	if _, err := os.Stat(*outputDir); err == nil && !*force {
		return fmt.Errorf("directory %s already exists (use --force to overwrite)", *outputDir)
	}

	fmt.Printf("Creating iOS project for %s...\n", appName)

	// Template data
	data := IOSTemplateData{
		AppName:          appName,
		SafeName:         safeName,
		BundleIdentifier: config.IOS.BundleIdentifier,
		DeploymentTarget: config.IOS.DeploymentTarget,
		DevelopmentTeam:  config.IOS.DevelopmentTeam,
		Version:          config.App.Version,
	}

	// Create directory structure
	dirs := []string{
		*outputDir,
		filepath.Join(*outputDir, safeName+".xcodeproj"),
		filepath.Join(*outputDir, safeName),
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Generate files
	files := map[string]string{
		filepath.Join(*outputDir, safeName+".xcodeproj", "project.pbxproj"): iosProjectTemplate,
		filepath.Join(*outputDir, safeName, "Info.plist"):                   iosInfoPlistTemplate,
		filepath.Join(*outputDir, "README.md"):                              iosReadmeTemplate,
	}

	for path, tmplStr := range files {
		if err := writeTemplate(path, tmplStr, data); err != nil {
			return fmt.Errorf("failed to write %s: %w", path, err)
		}
		fmt.Printf("  ✓ Created %s\n", path)
	}

	fmt.Println("")
	fmt.Printf("✓ iOS project created in %s/\n", *outputDir)
	fmt.Println("")
	fmt.Println("Next steps:")
	fmt.Println("  1. Build the Rust engine for iOS:")
	fmt.Println("     ctd build-ios --simulator")
	fmt.Println("  2. Open the Xcode project:")
	fmt.Printf("     open %s/%s.xcodeproj\n", *outputDir, safeName)
	fmt.Println("  3. Or run directly on simulator:")
	fmt.Println("     ctd run-ios")

	return nil
}

type IOSTemplateData struct {
	AppName          string
	SafeName         string
	BundleIdentifier string
	DeploymentTarget string
	DevelopmentTeam  string
	Version          string
}

func writeTemplate(path, tmplStr string, data interface{}) error {
	tmpl, err := template.New("").Parse(tmplStr)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, data)
}

// iOS project templates
const iosInfoPlistTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleExecutable</key>
	<string>{{.SafeName}}</string>
	<key>CFBundleIdentifier</key>
	<string>{{.BundleIdentifier}}</string>
	<key>CFBundleName</key>
	<string>{{.AppName}}</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>{{.Version}}</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UIStatusBarHidden</key>
	<false/>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<false/>
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleDefault</string>
	<key>UILaunchStoryboardName</key>
	<string></string>
</dict>
</plist>
`

const iosProjectTemplate = `// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {
		/* This is a minimal Xcode project structure */
		/* The actual project.pbxproj is complex - this is a placeholder */
		/* Users should open Xcode and let it regenerate as needed */
	};
	rootObject = "{{.SafeName}}";
}
`

const iosReadmeTemplate = `# {{.AppName}} - iOS

This iOS project was generated by ` + "`ctd create-ios`" + `.

## Building

### Prerequisites

1. Xcode 15+ installed
2. Rust toolchain with iOS targets:
   ` + "```bash" + `
   rustup target add aarch64-apple-ios        # Physical device
   rustup target add aarch64-apple-ios-sim    # Simulator (Apple Silicon)
   rustup target add x86_64-apple-ios         # Simulator (Intel)
   ` + "```" + `

### Build for Simulator

` + "```bash" + `
ctd build-ios --simulator
` + "```" + `

### Build for Device

` + "```bash" + `
ctd build-ios --device
` + "```" + `

### Run on Simulator

` + "```bash" + `
ctd run-ios
` + "```" + `

## Project Structure

` + "```" + `
ios/
├── {{.SafeName}}.xcodeproj/   # Xcode project
├── {{.SafeName}}/
│   └── Info.plist             # App configuration
└── README.md                  # This file
` + "```" + `

## Configuration

Edit ` + "`centered.toml`" + ` in your project root to configure:

` + "```toml" + `
[ios]
deployment_target = "{{.DeploymentTarget}}"
development_team = "{{.DevelopmentTeam}}"
bundle_identifier = "{{.BundleIdentifier}}"
` + "```" + `
`
